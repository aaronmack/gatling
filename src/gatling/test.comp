#version 450 core

#extension GL_EXT_shader_16bit_storage: require

layout(local_size_x=32, local_size_y=32, local_size_z=1) in;

layout(set=0, binding=0) writeonly buffer ImageBuffer {
    vec4 pixel[];
};

layout(set=0, binding=1) readonly buffer IndexBuffer {
    uint data[];
} index_buf;

layout(set=0, binding=2) readonly buffer VertexBuffer {
    vec4 data[];
} vertex_buf;

const vec4 BACKGROUND_COLOR = vec4(0.8, 0.8, 0.8, 1.0);

const vec3 MAT_COLOR = vec3(0.2, 1.0, 0.0);
const float MAT_DIFFUSE_COEFF = 0.15;
const float MAT_SPECULAR_COEFF = 0.65;
const float MAT_SHININESS = 22.0;

const vec3 LIGHT_POSITION = vec3 (2.0, 5.0, 5.0);
const vec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);

const float EPS = 0.000001;

// MÃ¶ller-Trumbore triangle intersection.
bool intersect_triangle(
    in vec3 ray_origin,
    in vec3 ray_direction,
    in vec3 v0, in vec3 v1, in vec3 v2,
    out float bc_u, out float bc_v, out float t
) {
    const vec3 e1 = v1 - v0;
    const vec3 e2 = v2 - v0;
    const vec3 p = cross(ray_direction, e2);
    const float det = dot(e1, p);

    if (abs(det) < EPS) {
        return false;
    }

    const float invDet = 1.0 / det;

    const vec3 tvec = ray_origin - v0;

    bc_u = dot(tvec, p) * invDet;
    if (bc_u < -EPS || (bc_u > (1.0+EPS))) {
        return false;
    }

    const vec3 q = cross(tvec, e1);
    bc_v = dot(ray_direction, q) * invDet;

    if (bc_v < -EPS || (bc_u + bc_v > (1.0+EPS))) {
        return false;
    }

    t = dot(e2, q) * invDet;

    return t > EPS;
}

vec4 phong(vec3 ray_origin, vec3 ray_direction, vec3 surface_hit, vec3 normal)
{
    vec3 light_to_surface = LIGHT_POSITION - surface_hit;

    float diffuse_coeff = max(dot(normal, light_to_surface), 0.0);
    vec3 diffuse_color = MAT_COLOR * MAT_DIFFUSE_COEFF * diffuse_coeff * LIGHT_COLOR;

    vec3 eye = normalize(-surface_hit);
    vec3 surface_reflected_cam = normalize(reflect(-light_to_surface, normal));
    float specular_coeff = pow(max(dot(eye, surface_reflected_cam), 0.0), MAT_SHININESS);
    vec3 specular_color = MAT_SPECULAR_COEFF * specular_coeff * LIGHT_COLOR;

    return vec4(diffuse_color + specular_color, 1.0);
}

void main()
{
    const uint vertex_offset_bytes = index_buf.data[0];
    const uint vertex_count        = index_buf.data[1];
    const uint index_offset_bytes  = index_buf.data[2];
    const uint index_count         = index_buf.data[3];

    const uint vertex_offset_vec4s = vertex_offset_bytes / 16;
    const uint index_offset_uints = index_offset_bytes / 4;

    const vec3 ray_origin = vec3(
         1.0,
        -1.0 + 2.0 * (gl_GlobalInvocationID.y / 1024.0),
        -1.0 + 2.0 * (gl_GlobalInvocationID.x / 1024.0)
    );

    const vec3 ray_direction = vec3(-1.0, 0.0, 0.0);

    vec4 color = BACKGROUND_COLOR;

    float t = 100000.0;

    for (uint i = 0; i < index_count; i += 3)
    {
        const uint index_offset = index_offset_uints + i;

        const uint i_0 = index_buf.data[index_offset + 0];
        const uint i_1 = index_buf.data[index_offset + 1];
        const uint i_2 = index_buf.data[index_offset + 2];

        const vec4 v0_f1 = vertex_buf.data[vertex_offset_vec4s + i_0 * 2 + 0];
        const vec4 v0_f2 = vertex_buf.data[vertex_offset_vec4s + i_0 * 2 + 1];
        const vec4 v1_f1 = vertex_buf.data[vertex_offset_vec4s + i_1 * 2 + 0];
        const vec4 v1_f2 = vertex_buf.data[vertex_offset_vec4s + i_1 * 2 + 1];
        const vec4 v2_f1 = vertex_buf.data[vertex_offset_vec4s + i_2 * 2 + 0];
        const vec4 v2_f2 = vertex_buf.data[vertex_offset_vec4s + i_2 * 2 + 1];

        const vec3 v0_p  = v0_f1.xyz;
        const vec3 v0_n  = vec3(v0_f1.w, v0_f2.xy);
        const vec2 v0_uv = v0_f2.zw;
        const vec3 v1_p  = v1_f1.xyz;
        const vec3 v1_n  = vec3(v1_f1.w, v1_f2.xy);
        const vec2 v1_uv = v1_f2.zw;
        const vec3 v2_p  = v2_f1.xyz;
        const vec3 v2_n  = vec3(v2_f1.w, v2_f2.xy);
        const vec2 v2_uv = v2_f2.zw;

        float bc_u, bc_v, t_temp;
        if (intersect_triangle(
            ray_origin, ray_direction, v0_p, v1_p, v2_p,
            bc_u, bc_v, t_temp)) {
            if (t_temp < t) {
                t = t_temp;
                vec3 surface_hit = ray_origin + ray_direction * t;
                vec3 normal = normalize(v0_n * (1.0 - bc_u - bc_v) + v1_n * bc_u + v2_n * bc_v);
                color = phong(ray_origin, ray_direction, surface_hit, normal);
            }
        }
    }

    const uint index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * 1024;
    pixel[index] = color;
}
