#version 450 core

#extension GL_EXT_shader_16bit_storage: require

layout(local_size_x=32, local_size_y=32, local_size_z=1) in;

layout(set=0, binding=0) writeonly buffer ImageBuffer {
    vec4 pixel[];
};

layout(set=0, binding=1) readonly buffer IndexBuffer {
    uint data[];
} index_buf;

layout(set=0, binding=2) readonly buffer VertexBuffer {
    vec4 data[];
} vertex_buf;

const vec4 COLOR_LIGHT_BLUE = vec4(0.5, 0.7, 1.0, 1.0);
const vec4 COLOR_LIGHT_GRAY = vec4(0.8, 0.8, 0.8, 1.0);

const vec3 LIGHT_POSITION = vec3 (2.0, 5.0, 5.0);
const vec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);

const float EPS = 0.000001;

const uint NUM_SAMPLES = 8;

// MÃ¶ller-Trumbore triangle intersection.
bool intersect_triangle(
    in vec3 ray_origin,
    in vec3 ray_direction,
    in vec3 v0, in vec3 v1, in vec3 v2,
    out float bc_u, out float bc_v, out float t
) {
    const vec3 e1 = v1 - v0;
    const vec3 e2 = v2 - v0;
    const vec3 p = cross(ray_direction, e2);
    const float det = dot(e1, p);

    if (abs(det) < EPS) {
        return false;
    }

    const float invDet = 1.0 / det;

    const vec3 tvec = ray_origin - v0;

    bc_u = dot(tvec, p) * invDet;
    if (bc_u < -EPS || (bc_u > (1.0+EPS))) {
        return false;
    }

    const vec3 q = cross(tvec, e1);
    bc_v = dot(ray_direction, q) * invDet;

    if (bc_v < -EPS || (bc_u + bc_v > (1.0+EPS))) {
        return false;
    }

    t = dot(e2, q) * invDet;

    return t > EPS;
}

vec4 phong(
    vec3 ray_origin,
    vec3 ray_direction,
    vec3 surface_hit,
    vec3 normal,
    vec3 mat_color,
    float mat_diffuse_coeff,
    float mat_specular_coeff,
    float mat_shininess)
{
    vec3 light_to_surface = LIGHT_POSITION - surface_hit;

    float diffuse_coeff = max(dot(normal, light_to_surface), 0.0);
    vec3 diffuse_color = mat_color * mat_diffuse_coeff * diffuse_coeff * LIGHT_COLOR;

    vec3 eye = normalize(-surface_hit);
    vec3 surface_reflected_cam = normalize(reflect(-light_to_surface, normal));
    float specular_coeff = pow(max(dot(eye, surface_reflected_cam), 0.0), mat_shininess);
    vec3 specular_color = mat_specular_coeff * specular_coeff * LIGHT_COLOR;

    return vec4(diffuse_color + specular_color, 1.0);
}

// TODO: use different random number generation
uint random_seed;

uint wang_hash(uint seed)
{
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float random_number_between_0_and_1()
{
  random_seed ^= random_seed << 13;
  random_seed ^= random_seed >> 17;
  random_seed ^= random_seed << 5;
  return float(random_seed) * (1.0 / 4294967296.0);
}

void main()
{
    const uint thread_id = gl_GlobalInvocationID.x +
                           gl_GlobalInvocationID.y +
                           gl_GlobalInvocationID.z;
    if (thread_id >= 1024 * 1024) {
        return;
    }

    random_seed = wang_hash(thread_id);

    const uint vertex_offset_bytes = index_buf.data[0];
    const uint vertex_count        = index_buf.data[1];
    const uint index_offset_bytes  = index_buf.data[2];
    const uint index_count         = index_buf.data[3];

    const uint vertex_offset_vec4s = vertex_offset_bytes / 16;
    const uint index_offset_uints = index_offset_bytes / 4;

    const float bg_t = gl_GlobalInvocationID.y / 1024.0;
    const vec4 background_color =
        (1.0 - bg_t) * COLOR_LIGHT_GRAY + bg_t * COLOR_LIGHT_BLUE;

    vec4 color = vec4(0.0);

    for (uint s = 0; s < NUM_SAMPLES; ++s)
    {
        const vec3 ray_origin = vec3(
           1.0,
           -1.0 + 2.0 * (
               (gl_GlobalInvocationID.y + random_number_between_0_and_1()) / 1024.0),
           -1.0 + 2.0 * (
               (gl_GlobalInvocationID.x + random_number_between_0_and_1()) / 1024.0)
        );

        const vec3 ray_direction = vec3(-1.0, 0.0, 0.0);

        vec4 sample_color = background_color;

        float t = 100000.0;
        for (uint i = 0; i < index_count; i += 3)
        {
            const uint index_offset = index_offset_uints + i;

            const uint i_0 = index_buf.data[index_offset + 0];
            const uint i_1 = index_buf.data[index_offset + 1];
            const uint i_2 = index_buf.data[index_offset + 2];

            const vec4 v0_f1 = vertex_buf.data[vertex_offset_vec4s + i_0 * 2 + 0];
            const vec4 v0_f2 = vertex_buf.data[vertex_offset_vec4s + i_0 * 2 + 1];
            const vec4 v1_f1 = vertex_buf.data[vertex_offset_vec4s + i_1 * 2 + 0];
            const vec4 v1_f2 = vertex_buf.data[vertex_offset_vec4s + i_1 * 2 + 1];
            const vec4 v2_f1 = vertex_buf.data[vertex_offset_vec4s + i_2 * 2 + 0];
            const vec4 v2_f2 = vertex_buf.data[vertex_offset_vec4s + i_2 * 2 + 1];

            const vec3 v0_p  = v0_f1.xyz;
            const vec3 v0_n  = vec3(v0_f1.a, v0_f2.xy);
            const vec2 v0_uv = v0_f2.zw;
            const vec3 v1_p  = v1_f1.xyz;
            const vec3 v1_n  = vec3(v1_f1.a, v1_f2.xy);
            const vec2 v1_uv = v1_f2.zw;
            const vec3 v2_p  = v2_f1.xyz;
            const vec3 v2_n  = vec3(v2_f1.a, v2_f2.xy);
            const vec2 v2_uv = v2_f2.zw;

            float bc_u, bc_v, t_temp;
            if (intersect_triangle(
              ray_origin,
              ray_direction,
              v0_p, v1_p, v2_p,
              bc_u, bc_v, t_temp
              ))
            {
                if (t_temp < t)
                {
                    t = t_temp;
                    vec3 surface_hit = ray_origin + ray_direction * t;
                    vec3 normal = normalize(
                        v0_n * (1.0 - bc_u - bc_v) +
                        v1_n * bc_u +
                        v2_n * bc_v
                    );

                    const vec3 mat_color = abs(normal);
                    const float mat_diffuse_coeff = 0.25;
                    const float mat_specular_coeff = 0.75;
                    const float mat_shininess = 20.0;

                    sample_color = phong(
                        ray_origin,
                        ray_direction,
                        surface_hit,
                        normal,
                        mat_color,
                        mat_diffuse_coeff,
                        mat_specular_coeff,
                        mat_shininess
                    );
                }
            }
        }
        color += clamp(sample_color, 0.0, 1.0);
    }
    color /= float(NUM_SAMPLES);

    const uint index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * 1024;
    pixel[index] = color;
}
