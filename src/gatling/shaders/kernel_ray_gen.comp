#version 450 core

#include "extensions.glsl"
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 32, local_size_z = 1) in;
layout(constant_id = 0) const uint SAMPLE_COUNT = 1;
layout(constant_id = 1) const uint IMAGE_WIDTH = 3840;
layout(constant_id = 2) const uint IMAGE_HEIGHT = 2160;
layout(constant_id = 3) const float CAMERA_ORIGIN_X = 15.0;
layout(constant_id = 4) const float CAMERA_ORIGIN_Y = 15.0;
layout(constant_id = 5) const float CAMERA_ORIGIN_Z = 15.0;
layout(constant_id = 6) const float CAMERA_TARGET_X = 0.0;
layout(constant_id = 7) const float CAMERA_TARGET_Y = 4.0;
layout(constant_id = 8) const float CAMERA_TARGET_Z = 3.0;
layout(constant_id = 9) const float CAMERA_FOV = radians(50.0);

uint wang_hash(uint seed)
{
    seed = (seed ^ 61u) ^ (seed >> 16);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return seed;
}

uint random_seed;

float random_number_between_0_and_1()
{
  random_seed ^= random_seed << 13u;
  random_seed ^= random_seed >> 17u;
  random_seed ^= random_seed << 5u;
  return float(random_seed) * (1.0 / 4294967296.0);
}

void main()
{
  if (gl_GlobalInvocationID.x >= IMAGE_WIDTH ||
      gl_GlobalInvocationID.y >= IMAGE_HEIGHT) {
      return;
  }

  const uint pixel_index = gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * IMAGE_WIDTH;

  /* Reset counters to zero. */
  if (pixel_index == 0)
  {
    path_segment_counter = 0;
    hit_write_counter = 0;
    hit_read_counter = 0;
  }

  /* Use the pixel index as a base for a randomness seed. */
  random_seed = wang_hash(pixel_index);

  /* Generate mulitple rays originating from the camera. */
  const vec3 camera_origin = vec3(CAMERA_ORIGIN_X, CAMERA_ORIGIN_Y, CAMERA_ORIGIN_Z);
  const vec3 camera_target = vec3(CAMERA_TARGET_X, CAMERA_TARGET_Y, CAMERA_TARGET_Z);
  const vec3 camera_forward = normalize(camera_target - camera_origin);
  const vec3 camera_right = normalize(cross(camera_forward, vec3(0.0, 1.0, 0.0)));
  const vec3 camera_up = cross(camera_right, camera_forward);
  const float aspect_ratio = float(IMAGE_WIDTH) / float(IMAGE_HEIGHT);
  const float dist_to_plane = 1.0 / tan(CAMERA_FOV * 0.5);

  [[unroll]]
  for (uint s = 0; s < SAMPLE_COUNT; ++s)
  {
    /* Find new point on camera plane with random offset. */
    const float r1 = random_number_between_0_and_1();
    const float r2 = random_number_between_0_and_1();
    const float norm_plane_pos_x = (float(gl_GlobalInvocationID.x) + r1) / float(IMAGE_WIDTH);
    const float norm_plane_pos_y = (float(gl_GlobalInvocationID.y) + r2) / float(IMAGE_HEIGHT);

    /* Convert from [0, 1] to [-1.0, 1.0] range. */
    const float centered_offset_x = (2.0 * norm_plane_pos_x) - 1.0;
    const float centered_offset_y = (2.0 * norm_plane_pos_y) - 1.0;

    /* Calculate ray properties. */
    const vec3 ray_origin = camera_origin;
    vec3 ray_direction =
      camera_right   * centered_offset_x * aspect_ratio +
      camera_up      * centered_offset_y +
      camera_forward * dist_to_plane;

    /* Beware: a single direction component must not be zero.
       This is because we often take the inverse of the direction. */
    ray_direction += vec3(equal(ray_direction, vec3(0.0))) * FLOAT_MIN;
    ray_direction = normalize(ray_direction);

    const uint sample_index = pixel_index * SAMPLE_COUNT + s;
    path_segments[sample_index].origin = ray_origin;
    path_segments[sample_index].pixel_index = pixel_index;
    path_segments[sample_index].dir = ray_direction;
    path_segments[sample_index].rec_depth = 0;
  }

  /* We also set the initial pixel color. */
  pixels[pixel_index] = vec4(0.0, 0.0, 0.0, 1.0);
}
