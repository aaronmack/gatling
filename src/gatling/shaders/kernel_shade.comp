#version 450 core

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

#include "extensions.glsl"
#include "common.glsl"

vec4 shade(const hit_info hit)
{
    const face f = faces[hit.face_index];
    const vec3 n0 = vertices[f.v_0].field2.xyz;
    const vec3 n1 = vertices[f.v_1].field2.xyz;
    const vec3 n2 = vertices[f.v_2].field2.xyz;
    const vec2 bc = hit.bc;

    const vec3 normal = normalize(
        n0 * (1.0 - bc.x - bc.y) +
        n1 * bc.x +
        n2 * bc.y
    );

    const vec4 color = vec4(abs(normal), 1.0);

    return color;
}

void atomic_channel_exchange(uint buffer_index, float value)
{
    /* VK_EXT_shader_atomic_float was released a few days ago but
     * the ecosystem is not mature enough for it to be usable. */
    uint old, desired;
    do
    {
        old = atomicLoad(
            pixels[buffer_index],
            gl_ScopeQueueFamily,
            gl_StorageSemanticsBuffer,
            gl_SemanticsRelaxed
        );
        const float old_f = uintBitsToFloat(old);
        const float t = (old_f == -0.0) ? 1.0 : 0.5;
        desired = floatBitsToUint(mix(old_f, value, t));
    }
    while (atomicCompSwap(
                pixels[buffer_index], old, desired,
                gl_ScopeQueueFamily,
                gl_StorageSemanticsBuffer,
                gl_SemanticsRelaxed,
                gl_StorageSemanticsBuffer,
                gl_SemanticsRelaxed) != old);
}

void main()
{
    while(true)
    {
        const uint hit_index = atomicAdd(hit_read_counter, 1);
        if (hit_index >= hit_write_counter) {
            return;
        }

        const hit_info hit = hits[hit_index];

        const vec4 color = shade(hit);

        atomic_channel_exchange(hit.pixel_index * 4 + 0, color.r);
        atomic_channel_exchange(hit.pixel_index * 4 + 1, color.g);
        atomic_channel_exchange(hit.pixel_index * 4 + 2, color.b);
        atomic_channel_exchange(hit.pixel_index * 4 + 3, color.a);
    }
}
