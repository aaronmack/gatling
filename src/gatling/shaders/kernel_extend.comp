#version 450 core

layout(local_size_x=32, local_size_y=32, local_size_z=1) in;

#include "common.glsl"

#define FLOAT_MAX 3.402823466e38
#define FLOAT_MIN 1.175494351e-38f

const uint SAMPLE_COUNT = 1;
const uint IMAGE_WIDTH = 3840;
const uint IMAGE_HEIGHT = 2160;
const uint MSB = (1u << 31u);

const vec4 COLOR_LIGHT_BLUE = vec4(0.5, 0.7, 1.0, 1.0);
const vec4 COLOR_LIGHT_GRAY = vec4(0.8, 0.8, 0.8, 1.0);

const vec3 LIGHT_POSITION = vec3 (2.0, 5.0, 5.0);
const vec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);

const float TRI_EPS = 0.0000001;

/* MÃ¶ller-Trumbore triangle intersection. */
bool intersect_triangle(
    in const vec3 ray_origin,
    in const vec3 ray_direction,
    in const vec3 v0,
    in const vec3 v1,
    in const vec3 v2,
    out float bc_u,
    out float bc_v,
    out float t)
{
    const vec3 e1 = v1 - v0;
    const vec3 e2 = v2 - v0;
    const vec3 p = cross(ray_direction, e2);
    const float det = dot(e1, p);

    if (abs(det) < TRI_EPS) {
        return false;
    }

    const float invDet = 1.0 / det;

    const vec3 tvec = ray_origin - v0;

    bc_u = dot(tvec, p) * invDet;
    if (bc_u < 0.0 || bc_u > 1.0) {
        return false;
    }

    const vec3 q = cross(tvec, e1);
    bc_v = dot(ray_direction, q) * invDet;

    if (bc_v < 0.0 || (bc_u + bc_v > 1.0)) {
        return false;
    }

    t = dot(e2, q) * invDet;

    return t > 0.0;
}

/* Optimized ray-aabb intersection kernel by Aila et al. '12. */
bool intersect_aabb(
    in const float t_min,
    in const float t_max,
    in const aabb box,
    in const vec3 inv_dir,
    in const vec3 ood,
    out float t)
{
    float x0 = box.min_x * inv_dir.x - ood.x;
    float y0 = box.min_y * inv_dir.y - ood.y;
    float z0 = box.min_z * inv_dir.z - ood.z;
    float x1 = box.max_x * inv_dir.x - ood.x;
    float y1 = box.max_y * inv_dir.y - ood.y;
    float z1 = box.max_z * inv_dir.z - ood.z;

    t = max(max(t_min, min(x0, x1)), max(min(y0, y1), min(z0, z1)));
    float t_max_box = min(min(t_max, max(x0, x1)), min(max(y0, y1), max(z0, z1)));

    return t <= t_max_box;
}

bool test_leaf(
    in const path_segment ray,
    in const float t_max,
    in const uint tri_offset,
    in const uint tri_count,
    out hit_info hit_info,
    out float t)
{
    t = t_max;

    uint start = tri_offset;
    uint end   = tri_offset + tri_count;

    for (uint i = start; i < end; ++i)
    {
        const face f = faces[i];
        const vertex v_0 = vertices[f.v_0];
        const vertex v_1 = vertices[f.v_1];
        const vertex v_2 = vertices[f.v_2];

        float bc_u, bc_v, t_temp;

        const bool is_hit = intersect_triangle(
            ray.pos,
            ray.dir,
            vec3(v_0.pos_x, v_0.pos_y, v_0.pos_z),
            vec3(v_1.pos_x, v_1.pos_y, v_1.pos_z),
            vec3(v_2.pos_x, v_2.pos_y, v_2.pos_z),
            bc_u,
            bc_v,
            t_temp
        );
        if (!is_hit)
        {
            continue;
        }
        if (t_temp >= t)
        {
            continue;
        }

        t = t_temp;
        hit_info.face_index = i;
        hit_info.bc_u = bc_u;
        hit_info.bc_v = bc_v;
    }

    hit_info.pixel_index = ray.pixel_index;
    hit_info.pos = vec4(ray.pos + ray.dir * t, 1.0);

    return t != t_max;
}

struct stack_item
{
    uint node_index;
    float t_aabb_min;
};

void traverse_bvh(in const uint ray_index)
{
    const path_segment ray = path_segments[ray_index];

    float t_triangle_max =         FLOAT_MAX;
    float t_aabb_min     =               0.0;
    vec3 inv_dir         =     1.0 / ray.dir;
    vec3 ood             = ray.pos / ray.dir;

    const bool intersects_root = intersect_aabb(
        0.0, FLOAT_MAX, root_aabb, inv_dir, ood, t_aabb_min
    );
    if (!intersects_root) {
        return;
    }

    stack_item stack[32];
    int stack_index = 0;

    stack[0].node_index = 0;
    stack[0].t_aabb_min = t_aabb_min;

    hit_info hit;

    hit_info temp_hit;
    float temp_t;

    while(stack_index >= 0)
    {
        stack_item item = stack[stack_index];
        const uint node_index = item.node_index;
        t_aabb_min = item.t_aabb_min;
        stack_index--;

        bvh_node node = bvh_nodes[node_index];

        float t_aabb_min_left;
        const bool hit_left = intersect_aabb(
            t_aabb_min,
            t_triangle_max,
            node.left_aabb,
            inv_dir,
            ood,
            t_aabb_min_left
        );

        float t_aabb_min_right;
        const bool hit_right = intersect_aabb(
            t_aabb_min,
            t_triangle_max,
            node.right_aabb,
            inv_dir,
            ood,
            t_aabb_min_right
        );

        const bool is_left_leaf  = (node.left_child_count  & MSB) == MSB;
        const bool is_right_leaf = (node.right_child_count & MSB) == MSB;

        if (hit_left)
        {
            const uint child_offset = node.left_child_offset;

            if (is_left_leaf)
            {
                const uint child_count = (node.left_child_count << 1u) >> 1u;
                const bool has_hit = test_leaf(
                    ray,
                    t_triangle_max,
                    child_offset,
                    child_count,
                    temp_hit,
                    temp_t
                );

                if (has_hit)
                {
                    t_triangle_max = temp_t;
                    hit = temp_hit;
                }
            }
            else
            {
                stack_index++;
                stack[stack_index].node_index = child_offset;
                stack[stack_index].t_aabb_min = t_aabb_min_left;
            }
        }
        if (hit_right)
        {
            const uint child_offset = node.right_child_offset;

            if (is_right_leaf)
            {
                const uint child_count = (node.right_child_count << 1u) >> 1u;
                const bool has_hit = test_leaf(
                    ray,
                    t_triangle_max,
                    child_offset,
                    child_count,
                    temp_hit,
                    temp_t
                );

                if (has_hit)
                {
                    t_triangle_max = temp_t;
                    hit = temp_hit;
                }
            }
            else
            {
                stack_index++;
                stack[stack_index].node_index = child_offset;
                stack[stack_index].t_aabb_min = t_aabb_min_right;
            }
        }
    }

    if (t_triangle_max != FLOAT_MAX)
    {
        const uint hit_index = atomicAdd(hit_write_counter, 1);
        hits[hit_index] = hit;
    }
}

void main()
{
    const uint TOTAL_RAY_COUNT = IMAGE_WIDTH * IMAGE_HEIGHT * SAMPLE_COUNT;

    while(true)
    {
      const uint ray_index = atomicAdd(path_segment_counter, 1);

      if (ray_index >= TOTAL_RAY_COUNT) {
        return;
      }

      traverse_bvh(ray_index);
    }
}
