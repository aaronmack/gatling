#version 450 core

#include "extensions.glsl"
#include "common.glsl"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;
layout(constant_id = 1) const uint SAMPLE_COUNT = 1;
layout(constant_id = 2) const uint IMAGE_WIDTH = 3840;
layout(constant_id = 3) const uint IMAGE_HEIGHT = 2160;
layout(constant_id = 4) const uint MAX_STACK_SIZE = 32;

const vec4 COLOR_LIGHT_BLUE = vec4(0.5, 0.7, 1.0, 1.0);
const vec4 COLOR_LIGHT_GRAY = vec4(0.8, 0.8, 0.8, 1.0);
const vec3 LIGHT_POSITION = vec3 (2.0, 5.0, 5.0);
const vec3 LIGHT_COLOR = vec3(1.0, 1.0, 1.0);
const float TRI_EPS = 0.0000001;

/* MÃ¶ller-Trumbore triangle intersection. */
bool intersect_triangle(
    in const vec3 ray_origin,
    in const vec3 ray_direction,
    in const vec3 v0,
    in const vec3 v1,
    in const vec3 v2,
    out vec2 bc,
    out float t)
{
    const vec3 e1 = v1 - v0;
    const vec3 e2 = v2 - v0;
    const vec3 p = cross(ray_direction, e2);
    const float det = dot(e1, p);

    if (abs(det) < TRI_EPS) {
        return false;
    }

    const float inv_det = 1.0 / det;

    const vec3 t_vec = ray_origin - v0;

    bc.x = dot(t_vec, p) * inv_det;
    if (bc.x < 0.0 || bc.x > 1.0) {
        return false;
    }

    const vec3 q = cross(t_vec, e1);
    bc.y = dot(ray_direction, q) * inv_det;

    if (bc.y < 0.0 || (bc.x + bc.y > 1.0)) {
        return false;
    }

    t = dot(e2, q) * inv_det;

    return t > 0.0;
}

/* Optimized ray-aabb intersection kernel by Aila et al. '12. */
bool intersect_aabb(
    in const float t_min,
    in const float t_max,
    in const aabb box,
    in const vec3 inv_dir,
    in const vec3 ood,
    out float t)
{
    const float x0 = box.min_x * inv_dir.x - ood.x;
    const float y0 = box.min_y * inv_dir.y - ood.y;
    const float z0 = box.min_z * inv_dir.z - ood.z;
    const float x1 = box.max_x * inv_dir.x - ood.x;
    const float y1 = box.max_y * inv_dir.y - ood.y;
    const float z1 = box.max_z * inv_dir.z - ood.z;

    t = max(max(t_min, min(x0, x1)), max(min(y0, y1), min(z0, z1)));
    const float t_max_box = min(min(t_max, max(x0, x1)), min(max(y0, y1), max(z0, z1)));

    return t <= t_max_box;
}

bool test_leaf(
    in const path_segment ray,
    in const float t_max,
    in const uint tri_offset,
    in const uint tri_count,
    out hit_info hit_info,
    out float t)
{
    t = t_max;

    const uint start = tri_offset;
    const uint end = tri_offset + tri_count;

    for (uint i = start; i < end; ++i)
    {
        const face f = faces[i];
        const vec3 p0 = vertices[f.v_0].field1.xyz;
        const vec3 p1 = vertices[f.v_1].field1.xyz;
        const vec3 p2 = vertices[f.v_2].field1.xyz;

        vec2 bc;
        float t_temp;

        const bool is_hit = intersect_triangle(
            ray.origin, ray.dir,
            p0, p1, p2,
            bc, t_temp
        );

        if (!is_hit)
        {
            continue;
        }

        if (t_temp >= t)
        {
            continue;
        }

        t = t_temp;
        hit_info.face_index = i;
        hit_info.bc = bc;
    }

    return t != t_max;
}

struct stack_item
{
    uint node_index;
    float t_aabb_min;
};

void traverse_bvh(in const uint ray_index)
{
    const path_segment ray = path_segments[ray_index];

    const vec3 inv_dir = 1.0 / ray.dir;
    const vec3 ood = ray.origin / ray.dir;

    float t_face_max = FLOAT_MAX;
    int stack_index = 0;

    stack_item stack[MAX_STACK_SIZE];
    stack[0].node_index = 0;
    stack[0].t_aabb_min = 0.0;

    hit_info hit;
    hit_info temp_hit;

    float temp_t;

    while(stack_index >= 0)
    {
        stack_item item = stack[stack_index];
        stack_index--;

        const uint node_index = item.node_index;
        const float t_aabb_min = item.t_aabb_min;

        bvh_node node = bvh_nodes[node_index];

        const bool hit_aabb = intersect_aabb(
            t_aabb_min,
            t_face_max,
            node.aabb,
            inv_dir,
            ood,
            temp_t
        );

        if (!hit_aabb)
        {
            continue;
        }

        const bool is_leaf = (node.field2 & 0x80000000) == 0x80000000;

        if (is_leaf)
        {
            const uint child_offset = node.field1;
            const uint child_count = node.field2 & 0x7FFFFFFF;

            const bool has_hit = test_leaf(
                ray,
                t_face_max,
                child_offset,
                child_count,
                temp_hit,
                temp_t
            );

            if (has_hit)
            {
                hit = temp_hit;
                hit.pos = vec4(ray.origin + ray.dir * temp_t, 1.0);
                t_face_max = temp_t;
            }
        }
        else
        {
            stack_index++;
            stack[stack_index].node_index = node.field1;
            stack[stack_index].t_aabb_min = temp_t;
            stack_index++;
            stack[stack_index].node_index = node.field2;
            stack[stack_index].t_aabb_min = temp_t;
        }
    }

    if (t_face_max != FLOAT_MAX)
    {
        const uint hit_index = atomicAdd(hit_write_counter, 1);
        hit.pixel_index = ray.pixel_index;
        hits[hit_index] = hit;
    }
}

void main()
{
    const uint TOTAL_RAY_COUNT = IMAGE_WIDTH * IMAGE_HEIGHT * SAMPLE_COUNT;

    while(true)
    {
      const uint ray_index = atomicAdd(path_segment_counter, 1);

      if (ray_index >= TOTAL_RAY_COUNT) {
        return;
      }

      traverse_bvh(ray_index);
    }
}
