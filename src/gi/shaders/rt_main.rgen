#extension GL_GOOGLE_include_directive: require
#extension GL_EXT_ray_tracing: require
#extension GL_EXT_control_flow_attributes: require
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_EXT_shader_explicit_arithmetic_types_int16: require

#include "rt_payload.glsl"
#include "rt_descriptors.glsl"
#include "colormap.glsl"

layout(location = PAYLOAD_INDEX_SHADE) rayPayloadEXT ShadeRayPayload rayPayload;

vec3 evaluate_sample(vec3 ray_origin,
                     vec3 ray_dir,
#ifdef RAND_4D
                     uvec4 rng_state)
#else
                     uint rng_state)
#endif
{
    rayPayload.throughput = f16vec3(vec3(1.0));
    rayPayload.bitfield   = uint16_t(0);
    rayPayload.radiance   = f16vec3(vec3(0.0));
    rayPayload.rng_state  = rng_state;

#if AOV_ID == AOV_ID_DEBUG_BOUNCES
    uint bounce = 0;
#endif

    // Path trace
    [[loop]]
    while ((rayPayload.bitfield & 0x7FFFu) <= PC.maxBounces)
    {
        traceRayEXT(
            sceneAS,            // top-level AS
            0,                  // rayFlags
            0xFF,               // cullMask
            0,                  // sbtRecordOffset
            2,                  // sbtRecordStride
            0,                  // missIndex
            ray_origin,         // ray origin
            0.0,                // ray min range
            ray_dir,            // ray direction
            FLOAT_MAX,          // ray max range
            PAYLOAD_INDEX_SHADE // payload
        );

        ray_origin = rayPayload.ray_origin;
        ray_dir = rayPayload.ray_dir;

#if AOV_ID == AOV_ID_DEBUG_BOUNCES
        bounce++;
#endif
    }

#if AOV_ID == AOV_ID_DEBUG_BOUNCES
    return colormap_inferno(float(bounce) / float(PC.maxBounces));
#endif

    // Radiance clamping
    vec3 radiance = vec3(rayPayload.radiance);
    float maxValue = max(radiance.r, max(radiance.g, radiance.b));
    if (maxValue > PC.maxSampleValue)
    {
        radiance *= PC.maxSampleValue / maxValue;
    }

    return max(vec3(0.0), radiance);
}

void main()
{
#if AOV_ID == AOV_ID_DEBUG_CLOCK_CYCLES
    uint64_t start_cycle_count = clockARB();
#endif

    uvec2 pixel_pos = gl_LaunchIDEXT.xy;
    uint pixel_index = pixel_pos.x + pixel_pos.y * PC.imageWidth;

    vec3 camera_right = cross(PC.cameraForward, PC.cameraUp);
    float aspect_ratio = float(PC.imageWidth) / float(PC.imageHeight);

    float H = 1.0;
    float W = H * aspect_ratio;
    float d = H / (2.0 * tan(PC.cameraVFoV * 0.5));

    float WX = W / float(PC.imageWidth);
    float HY = H / float(PC.imageHeight);

    vec3 C = PC.cameraPosition + PC.cameraForward * d;
    vec3 L = C - camera_right * W * 0.5 - PC.cameraUp * H * 0.5;

    float inv_sample_count = 1.0 / float(PC.sampleCount);

    vec3 pixel_color = vec3(0.0, 0.0, 0.0);
    for (uint s = 0; s < PC.sampleCount; ++s)
    {
        uint sampleIndex = PC.sampleOffset + s;
#ifdef RAND_4D
        uvec4 rng_state = rng4d_init(pixel_pos.xy, sampleIndex);
        vec4 k = rng4d_next(rng_state);
        float k1 = k.x;
        float k2 = k.y;
#else
        uint rng_state = rng_init(pixel_index, sampleIndex);
        float k1 = rng_next(rng_state);
        float k2 = rng_next(rng_state);
#endif

        vec3 P =
            L +
            (float(pixel_pos.x) + k1) * camera_right * WX +
            (float(pixel_pos.y) + k2) * PC.cameraUp * HY;

        vec3 ray_origin = PC.cameraPosition;
        vec3 ray_dir = P - ray_origin;

        /* Beware: a single direction component must not be zero,
         * because we often take the inverse of the direction. */
        ray_dir += vec3(equal(ray_dir, vec3(0.0))) * FLOAT_MIN;

        ray_dir = normalize(ray_dir);

        /* Path trace sample and accumulate color. */
        vec3 sample_color = evaluate_sample(ray_origin, ray_dir, rng_state);
        pixel_color += sample_color * inv_sample_count;
    }

#if AOV_ID == AOV_ID_DEBUG_CLOCK_CYCLES
    float cycles_elapsed_norm = float(clockARB() - start_cycle_count) / float(UINT32_MAX);
    pixel_color = vec3(cycles_elapsed_norm, 0.0, 0.0);
#endif

    if (PC.sampleOffset > 0)
    {
      float inv_total_sample_count = 1.0 / float(PC.sampleOffset + PC.sampleCount);

      float weight_old = float(PC.sampleOffset) * inv_total_sample_count;
      float weight_new = float(PC.sampleCount) * inv_total_sample_count;

      pixel_color = weight_old * pixels[pixel_index].rgb + weight_new * pixel_color;
    }

    pixels[pixel_index] = vec4(pixel_color, 1.0);
}
