#extension GL_GOOGLE_include_directive: require
#extension GL_EXT_ray_tracing: require
#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_explicit_arithmetic_types_float16: require
#extension GL_EXT_shader_explicit_arithmetic_types_int16: require

#include "rt_payload.glsl"
#include "rt_descriptors.glsl"

layout(location = PAYLOAD_INDEX_SHADE) rayPayloadInEXT ShadeRayPayload rayPayload;

// Optimized implementation from GLM with only cross products:
// https://github.com/g-truc/glm/blob/47585fde0c49fa77a2bf2fb1d2ead06999fd4b6e/glm/detail/type_quat.inl#L356-L363
vec3 quatRotateDir(vec4 q, vec3 dir)
{
    vec3 a = cross(q.xyz, dir);
    vec3 b = cross(q.xyz, a);
    return dir + ((a * q.w) + b) * 2.0;
}

#ifdef DOMELIGHT_ENABLED
vec3 sampleDomeLight(vec3 rayDir)
{
    float u = (atan(rayDir.z, rayDir.x) + 0.5 * PI) / (2.0 * PI);
    float v = acos(rayDir.y) / PI;

    const uint lodLevel = 0;
    const uint domeLightTexIndex = 0;
    return textureLod(sampler2D(textures_2d[domeLightTexIndex], tex_sampler), vec2(u, v), lodLevel).rgb;
}
#endif

void main()
{
    vec3 backgroundColor = PC.backgroundColor.rgb;

#ifdef DOMELIGHT_ENABLED
#ifndef DOMELIGHT_CAMERA_VISIBLE
    bool isPrimaryRay = (rayPayload.bitfield & 0x7FFFu) == 0;
    if (!isPrimaryRay)
#endif
    {
        vec3 sampleDir = normalize(quatRotateDir(PC.domeLightRotation, gl_WorldRayDirectionEXT));
        backgroundColor = sampleDomeLight(sampleDir) * PC.domeLightEmissionMultiplier;
    }
#endif

    rayPayload.radiance += rayPayload.throughput * f16vec3(backgroundColor);
    rayPayload.bitfield = uint16_t(0xFFFFu);
}
