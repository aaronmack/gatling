//
// Copyright (C) 2019-2022 Pablo Delgado Kr√§mer
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.
//

#include "MtlxDocumentPatcher.h"

#include <MaterialXCore/Types.h>

#include <assert.h>

namespace mx = MaterialX;

const char* ENVVAR_DISABLE_PATCH_COLOR3_VECTOR3_MISMATCH = "GATLING_DOCPATCH_DISABLE_COLOR3_VECTOR3_MISMATCH";
const char* ENVVAR_DISABLE_PATCH_USDUVTEXTURE_SOURCECOLORSPACE = "GATLING_DOCPATCH_DISABLE_USDUVTEXTURE_SOURCECOLORSPACE";

const char* TYPE_COLOR3 = "color3";
const char* TYPE_VECTOR3 = "vector3";

void _SanitizeFilePath(std::string& path)
{
  // The MDL SDK does not take raw OS paths. First, only forward-facing slashes are allowed.
  std::replace(path.begin(), path.end(), '\\', '/');

  // Second, only UNIX-style absolute paths ('/' prefix, no double colon) are valid.
  bool hasDriveSpecifier = path.size() >= 2 && path[1] == ':';

  if (hasDriveSpecifier)
  {
    path[1] = path[0];
    path[0] = '/';
  }
}

void _SanitizeFilePaths(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::PortElementPtr portElem = elem->asA<mx::PortElement>();
    if (!portElem)
    {
      continue;
    }

    std::string portType = portElem->getType();
    if (portType != mx::FILENAME_TYPE_STRING)
    {
      continue;
    }

    mx::ValuePtr valuePtr = portElem->getValue();
    if (!valuePtr)
    {
      continue;
    }

    std::string path = valuePtr->asA<std::string>();

    _SanitizeFilePath(path);

    portElem->setValue(path, mx::FILENAME_TYPE_STRING);
  }
}

mx::PortElementPtr _GetPortInterface(mx::PortElementPtr port)
{
  mx::ElementPtr parent = port->getParent();
  if (!parent)
  {
    return nullptr;
  }

  mx::NodePtr node = parent->asA<mx::Node>();
  if (!node)
  {
    return nullptr;
  }

  mx::NodeDefPtr nodeDef = node->getNodeDef(mx::EMPTY_STRING, true);
  if (!nodeDef)
  {
    return nullptr;
  }

  return nodeDef->getChildOfType<mx::PortElement>(port->getName());
}

std::string _GetPortType(mx::PortElementPtr port)
{
  mx::PortElementPtr portInterface = _GetPortInterface(port);

  return portInterface ? portInterface->getType() : port->getType();
}

// Workaround for an implicit type conversion issue between vector3 and color3 that occurs in code
// generated by the MDL backend: https://github.com/AcademySoftwareFoundation/MaterialX/issues/1038
void _PatchColor3Vector3Mismatch(mx::DocumentPtr document, mx::InputPtr input, mx::OutputPtr output)
{
  bool isInputColor3 = _GetPortType(input) == TYPE_COLOR3;

  bool isPatchable = (isInputColor3 && _GetPortType(output) == TYPE_VECTOR3) ||
                     (_GetPortType(input) == TYPE_VECTOR3 && _GetPortType(output) == TYPE_COLOR3);

  if (!isPatchable)
  {
    return;
  }

  fprintf(stderr, "patching color3-vector3 type mismatch (set %s to disable)\n",
    ENVVAR_DISABLE_PATCH_COLOR3_VECTOR3_MISMATCH);

  std::string nodeCategory = "convert";
  std::string nodeName = mx::EMPTY_STRING; // auto-assign
  std::string nodeType = isInputColor3 ? TYPE_COLOR3 : TYPE_VECTOR3;
  mx::NodePtr node = document->addNode(nodeCategory, nodeName, nodeType);

  mx::InputPtr convertInput = node->addInput("in");
  convertInput->setConnectedOutput(output);

  // Can't clear because we need to preserve other attributes like 'colorspace'.
  input->removeAttribute(mx::PortElement::OUTPUT_ATTRIBUTE);
  input->removeAttribute(mx::PortElement::NODE_GRAPH_ATTRIBUTE);
  input->setType(nodeType);
  input->setConnectedNode(node);
}

void _PatchColor3Vector3Mismatches(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::InputPtr input = elem->asA<mx::Input>();
    if (!input)
    {
      continue;
    }

    mx::OutputPtr output = input->getConnectedOutput();
    if (!output)
    {
      continue;
    }

    _PatchColor3Vector3Mismatch(document, input, output);
  }
}

// HACK/FIXME:
// One big limitation of the MDL backend is currently that geompropvalue
// reader nodes are not implemented (they return a value of zero). By
// removing them, the default geomprop (e.g. UV0) is used, provided by the
// MDL state, which we can fill by anticipating certain geomprops/primvars
// on the Hydra side (e.g. the 'st' primvar). This way, we can still get
// proper texture coordinates in MOST cases, but not all.
void _PatchGeompropNodes(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::NodePtr node = elem->asA<mx::Node>();
    if (!node)
    {
      continue;
    }

    mx::NodeDefPtr nodeDef = node->getNodeDef(mx::EMPTY_STRING, true);
    if (!nodeDef)
    {
      continue;
    }

    std::string nodeDefName = nodeDef->getName();
    if (strstr(nodeDefName.c_str(), "ND_geompropvalue") ||
        strstr(nodeDefName.c_str(), "ND_UsdPrimvarReader"))
    {
      document->removeNode(node->getName());
      continue;
    }

    if (strstr(nodeDefName.c_str(), "ND_image") == nullptr &&
        strstr(nodeDefName.c_str(), "ND_tiledimage") == nullptr)
    {
      continue;
    }

    auto texCoordInput = node->getActiveInput("texcoord");
    if (texCoordInput)
    {
      node->removeInput(texCoordInput->getName());
    }
  }
}

// According to the UsdPreviewSurface spec, the UsdUVTexture node has a sourceColorSpace input,
// which can take on the values 'raw', 'sRGB' and 'auto':
// https://graphics.pixar.com/usd/release/spec_usdpreviewsurface.html#texture-reader
//
// The MaterialX implementation does not provide this input, because color space transformations
// are supposed to be handled by node _attributes_ instead of inputs. Attributes can not be set
// dynamically. To work around the incompatibility of both approaches, this function replaces
// said input with the corresponding 'colorspace' attribute.
void _PatchUsdUVTextureSourceColorSpace(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::InputPtr textureInput = elem->asA<mx::Input>();
    if (!textureInput || textureInput->hasColorSpace())
    {
      continue;
    }

    mx::ElementPtr upstreamElem = textureInput->getParent();
    if (!upstreamElem)
    {
      continue;
    }

    mx::NodePtr upstreamNode = upstreamElem->asA<mx::Node>();
    mx::NodePtr downstreamNode = textureInput->getConnectedNode();
    if (!upstreamNode || !downstreamNode || downstreamNode->hasColorSpace())
    {
      continue;
    }

    mx::NodeDefPtr upstreamNodeDef = upstreamNode->getNodeDef(mx::EMPTY_STRING, true);
    mx::NodeDefPtr downstreamNodeDef = downstreamNode->getNodeDef(mx::EMPTY_STRING, true);
    if (!upstreamNodeDef || !downstreamNodeDef)
    {
      continue;
    }

    std::string downstreamNodeDefName = downstreamNodeDef->getName();
    if (!strstr(downstreamNodeDefName.c_str(), "ND_UsdUVTexture")) // strstr because of versioning suffix
    {
      continue;
    }

    mx::InputPtr colorSpaceInput = downstreamNode->getActiveInput("sourceColorSpace");
    mx::string textureInputName = textureInput->getName();

    std::string colorSpaceString = colorSpaceInput ? colorSpaceInput->getValueString() : "auto";

    bool isSrgbInput = (upstreamNodeDef->getName() == "ND_UsdPreviewSurface_surfaceshader" &&
      (textureInputName == "diffuseColor" || textureInputName == "emissiveColor" || textureInputName == "specularColor"));

    // Not spec-conform but should be more correct in most cases.
    bool isSrgbColorSpace = (colorSpaceString == "sRGB") || (colorSpaceString == "auto" && isSrgbInput);

    fprintf(stderr, "setting color space attribute from UsdUVTexture:sourceColorSpace (set %s to disable)\n",
      ENVVAR_DISABLE_PATCH_USDUVTEXTURE_SOURCECOLORSPACE);

    textureInput->setColorSpace(isSrgbColorSpace ? "srgb_texture" : "lin_rec709");

    // Prevent any other kind of processing.
    if (colorSpaceInput)
    {
      downstreamNode->removeInput(colorSpaceInput->getName());
    }
  }
}

namespace sg
{
  void MtlxDocumentPatcher::patch(MaterialX::DocumentPtr document)
  {
    _SanitizeFilePaths(document);

    if (!getenv(ENVVAR_DISABLE_PATCH_USDUVTEXTURE_SOURCECOLORSPACE))
    {
      _PatchUsdUVTextureSourceColorSpace(document);
    }

    _PatchGeompropNodes(document);

    if (!getenv(ENVVAR_DISABLE_PATCH_COLOR3_VECTOR3_MISMATCH))
    {
      _PatchColor3Vector3Mismatches(document);
    }
  }
}
