//
// Copyright (C) 2019-2022 Pablo Delgado Kr√§mer
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <https://www.gnu.org/licenses/>.
//

#include "MtlxDocumentPatcher.h"

#include <MaterialXCore/Types.h>

#include <assert.h>

namespace mx = MaterialX;

const char* ENVVAR_DISABLE_PATCH_COLOR3_VECTOR3_MISMATCH = "GATLING_DOCPATCH_DISABLE_COLOR3_VECTOR3_MISMATCH";

const char* TYPE_COLOR3 = "color3";
const char* TYPE_VECTOR3 = "vector3";

void _SanitizeFilePath(std::string& path)
{
  // The MDL SDK does not take raw OS paths. First, only forward-facing slashes are allowed.
  std::replace(path.begin(), path.end(), '\\', '/');

  // Second, only UNIX-style absolute paths ('/' prefix, no double colon) are valid.
  bool hasDriveSpecifier = path.size() >= 2 && path[1] == ':';

  if (hasDriveSpecifier)
  {
    path[1] = path[0];
    path[0] = '/';
  }
}

void _SanitizeFilePaths(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::PortElementPtr portElem = elem->asA<mx::PortElement>();
    if (!portElem)
    {
      continue;
    }

    std::string portType = portElem->getType();
    if (portType != mx::FILENAME_TYPE_STRING)
    {
      continue;
    }

    mx::ValuePtr valuePtr = portElem->getValue();
    if (!valuePtr)
    {
      continue;
    }

    std::string path = valuePtr->asA<std::string>();

    _SanitizeFilePath(path);

    portElem->setValue(path, mx::FILENAME_TYPE_STRING);
  }
}

mx::PortElementPtr _GetPortInterface(mx::PortElementPtr port)
{
  mx::ElementPtr parent = port->getParent();
  if (!parent)
  {
    return nullptr;
  }

  mx::NodePtr node = parent->asA<mx::Node>();
  if (!node)
  {
    return nullptr;
  }

  mx::NodeDefPtr nodeDef = node->getNodeDef(mx::EMPTY_STRING, true);
  if (!nodeDef)
  {
    return nullptr;
  }

  return nodeDef->getChildOfType<mx::PortElement>(port->getName());
}

std::string _GetPortType(mx::PortElementPtr port)
{
  mx::PortElementPtr portInterface = _GetPortInterface(port);

  return portInterface ? portInterface->getType() : port->getType();
}

// Workaround for an implicit type conversion issue between vector3 and color3 that occurs in code
// generated by the MDL backend: https://github.com/AcademySoftwareFoundation/MaterialX/issues/1038
void _PatchColor3Vector3Mismatch(mx::DocumentPtr document, mx::InputPtr input, mx::OutputPtr output)
{
  bool isInputColor3 = _GetPortType(input) == TYPE_COLOR3;

  bool isPatchable = (isInputColor3 && _GetPortType(output) == TYPE_VECTOR3) ||
                     (_GetPortType(input) == TYPE_VECTOR3 && _GetPortType(output) == TYPE_COLOR3);

  if (!isPatchable)
  {
    return;
  }

  fprintf(stderr, "patching color3-vector3 type mismatch (set %s to disable)\n",
    ENVVAR_DISABLE_PATCH_COLOR3_VECTOR3_MISMATCH);

  std::string nodeCategory = "convert";
  std::string nodeName = mx::EMPTY_STRING; // auto-assign
  std::string nodeType = isInputColor3 ? TYPE_COLOR3 : TYPE_VECTOR3;
  mx::NodePtr node = document->addNode(nodeCategory, nodeName, nodeType);

  mx::InputPtr convertInput = node->addInput("in");
  convertInput->setConnectedOutput(output);

  input->clearContent();
  input->setType(nodeType);
  input->setConnectedNode(node);
}

void _PatchColor3Vector3Mismatches(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::InputPtr input = elem->asA<mx::Input>();
    if (!input)
    {
      continue;
    }

    mx::OutputPtr output = input->getConnectedOutput();
    if (!output)
    {
      continue;
    }

    _PatchColor3Vector3Mismatch(document, input, output);
  }
}

// HACK/FIXME:
// One big limitation of the MDL backend is currently that geompropvalue
// reader nodes are not implemented (they return a value of zero). By
// removing them, the default geomprop (e.g. UV0) is used, provided by the
// MDL state, which we can fill by anticipating certain geomprops/primvars
// on the Hydra side (e.g. the 'st' primvar). This way, we can still get
// proper texture coordinates in MOST cases, but not all.
void _PatchGeompropNodes(mx::DocumentPtr document)
{
  for (auto treeIt = document->traverseTree(); treeIt != mx::TreeIterator::end(); ++treeIt)
  {
    mx::ElementPtr elem = treeIt.getElement();

    mx::NodePtr node = elem->asA<mx::Node>();
    if (!node)
    {
      continue;
    }

    mx::NodeDefPtr nodeDef = node->getNodeDef(mx::EMPTY_STRING, true);
    if (!nodeDef)
    {
      continue;
    }

    std::string nodeDefName = nodeDef->getName();
    if (strstr(nodeDefName.c_str(), "ND_geompropvalue"))
    {
      document->removeNode(node->getName());
      continue;
    }

    if (strstr(nodeDefName.c_str(), "ND_image") == nullptr &&
        strstr(nodeDefName.c_str(), "ND_tiledimage") == nullptr)
    {
      continue;
    }

    auto& texCoordInput = node->getActiveInput("texcoord");
    if (texCoordInput)
    {
      node->removeInput(texCoordInput->getName());
    }
  }
}

namespace sg
{
  void MtlxDocumentPatcher::patch(MaterialX::DocumentPtr document)
  {
    _SanitizeFilePaths(document);

    _PatchGeompropNodes(document);

    if (!getenv(ENVVAR_DISABLE_PATCH_COLOR3_VECTOR3_MISMATCH))
    {
      _PatchColor3Vector3Mismatches(document);
    }
  }
}
